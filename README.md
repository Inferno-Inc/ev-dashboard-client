# EV Dashboard Client v0.1

## Disclaimer
> The EV Dashboard Client is not ready for production grade applications.

## Introduction
This repository provides apps and libraries to allow users and assets/devices to register in the ev-dashboard registry and obtain credentials for participation in a flexibility market.

This repository also provides documentation on the steps required to connect to the EV Dashboard.

## Connecting to the EV Dashboard
The EV Dashboard is an application which aggregates OCPI data (via the OCN) and Blockchain data for both EVs and charge points. It also facilitate the request and issuance process for credentials relating to a flexibility market. The steps needed to access the EV Dashboard and list your devices are details below.

### OCN Connection
The EV Dashboard Backend retrieves vehicle and chargepoint data from CPO and eMSP backends
via OCPI connections routed by the OCN.
In order to create an OCN connection to the EV Dashboard Backend, the following steps are required:
1. Connect to an OCN Node
2. Whitelist the EV Dashboard Backend (see the OCN Rules section of the [OCN Node Documentation](https://shareandcharge.bitbucket.io/)).
3. Agree to the service permissions (see "Agree to service permissions" section of [ocn-registry cli docs](https://bitbucket.org/shareandcharge/ocn-registry/src/master/))

### Registration in the EV Registry smart contract
The EV Registry smart contract is a registry of both users and devices (vehicles or chargepoints) which have agreed to participate in the EV Dashboard and the associated flexibility market.
Therefore, both users and devices can be registered and both are represented by a Volta address.
Devices are registered by a user (they cannot register themselves) and are associated to that user.

The steps for registration are:
1. Register as a user.
In order to register, you must first be listed a party in the OCN Registry smart contract. To register, you can use the `add-user` command of the [asset-operator-cli](apps/asset-operator-cli)

2. (Optional) Create device keypairs.
In order for a device to be registered in the EV Registry, they must have a Volta address.
New addresses with their associated private keys can be generated by using the `generate-key` command of the the [asset-operator-cli](apps/asset-operator-cli)

3. Register devices.
This can be done using the using the `add-device` command of the the [asset-operator-cli](apps/asset-operator-cli) 

### Sign into the EV Dashboard
As a CPO or eMSP, you can sign into the EV Dashboard in order to view your vehicles or chargepoints
and request prequalification credentials on their behalf.
In order to register as a CPO or eMSP, you need to obtain a verified credential of your respective role. This registration is done via the EnergyWeb Switchboard application. The Switchboard documentation on this process is available [here](https://energyweb.atlassian.net/wiki/spaces/SWITCH/pages/1712554033/Using+Switchboard#V.-Enrolments). In the case of the EV dashboard, this process can be initiated from the EV Dashboard login page.
At a high level the process is:
- Request a credential
- Get approval
- Add credential to your DID document

### Listening for prequalification requests
Install and start the [asset-operator-server](apps/asset-operator-server)

## Architecture Diagram

![EV Dashboard Client Architecture](https://github.com/energywebfoundation/ev-dashboard-client/blob/master/architecture.png)

## Component Descriptions

### Apps

The two apps which are available are the [asset-operator-server](#asset-operator-server)
and the [asset-operator-cli](#asset-operator-cli).

#### asset-operator-server
A node server which listens for NATS messages related to the EV charging prequalification process.

#### asset-operator-cli
A javascript cli which allows reading and writing to EV Registry smart contract as well as
generating keypairs for devices. 

### Libraries

#### did-hydrator

Perform operations on a device's DID and Credentials:
- Create a DID Document and fund the asset's EWC account
- Issue a credential and add as a service endpoint in the DID document

#### asset-registrar

Registers an asset or user in the `ev-registry` smart contract

#### prequalification-client

Listens for NATS events regarding prequalification credentials and handles them on behalf of asset(s).

#### signer-provider-interface

An interface which provides access to a Signer for a given DID

### Databases

#### key-manager

Optional component that can be used to centrally manage keys.
Implements `signer-provider-interface`.
Can generate a new address/key-pair and well as provide existing key-pairs.

## Development

This repository is a monorepo that uses [Rush](https://rushjs.io/) with the PNPM package manager.

PNPM is used for its speed and solution to NPM doppelgangers (as well as being the default option for rush). See comparison of [NPM vs PNPM vs Yarn for Rush](https://rushjs.io/pages/maintainer/package_managers/).

### Install PNPM and Rush

PNPM is required. See installation instructions here: https://pnpm.js.org/installation/

Rush is required. See installation instructions here: https://rushjs.io/pages/intro/get_started/

### Installing Dependencies

Use rush to install dependencies (not the package manager directly).
In other words, do not run `npm install` or `pnpm install`.
This is because [Rush optimizes](https://rushjs.io/pages/developer/new_developer/) by installing all of the dependency packages in a central folder, and then uses symlinks to create the “node_modules” folder for each of the projects.

```sh
$ rush install
```

### Compile & Build

Use rush to build.

```sh
$ rush build
```

### Linting and Formating

This repository use ESLint for code conventions and Prettier for syntax formatting.
Both are setup according to [Rush recommendations](https://rushjs.io/pages/maintainer/enabling_prettier/):
- ESLint is configured per project while Prettier is configured globally.
- Prettier is configured to run as a pre-commit hook.

### Publishing new version

Steps are currently:
1. Run `rush change` manually to generate change files
2. Run `rush version --bump` to convert change files to changelog entries and update package.json versions
3. Merge to `publish` branch to trigger publishing via GitHub actions